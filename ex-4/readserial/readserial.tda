// @lang=tda @ts=2

module readserial_properties(reset_n, clk, rxd,
 data, valid, cnt_s, cnt_en, state_s);

input logic reset_n;
input logic clk;
input logic rxd;
input logic[7:0] data;
input logic valid;
input logic[2:0] cnt_s;
input logic cnt_en;
input logic state_s;

parameter IDLE = 0;
parameter READDATA = 1;

`include "tidal.sv"
 

`begin_tda(ops)

sequence reset_sequence;
	!reset_n;
endsequence;

property reset;
	reset_sequence |=>
		
	t ##0 state_s == IDLE and
	t ##0 !valid and
	t ##0 !cnt_en and
	t ##0 cnt_s == 0;
endproperty;

sequence idle_sequence;
	rxd and state_s == IDLE and cnt_s == 0 and !cnt_en;
endsequence;

property stay_in_idle;
	t ##0 idle_sequence

	implies

	t ##1 (state_s == IDLE and !valid and cnt_s == 0 and !cnt_en);
endproperty;

sequence start_sequence;
	!rxd and state_s == IDLE and cnt_s == 0 and !cnt_en;
endsequence;

sequence in_idle_counter_is_0;
	state_s == IDLE and cnt_s == 0;
endsequence;

sequence in_idle_counter_not_enabled;
	state_s == IDLE and !cnt_en;
endsequence;

property read_byte;
	logic [7:0] tmp;

	t ##0 start_sequence and
	t ##0 in_idle_counter_is_0 and
	t ##0 in_idle_counter_not_enabled and
	t ##8 set_freeze(tmp, 
		{
			$past(rxd, 7), 
			$past(rxd, 6), 
			$past(rxd, 5), 
			$past(rxd, 4), 
			$past(rxd, 3), 
			$past(rxd, 2), 
			$past(rxd, 1),
		 	rxd
		})

	implies 
	
	t ##1 (state_s == READDATA and !valid) and
	t ##2 (state_s == READDATA and !valid) and
	t ##3 (state_s == READDATA and !valid) and
	t ##4 (state_s == READDATA and !valid) and
	t ##5 (state_s == READDATA and !valid) and
	t ##6 (state_s == READDATA and !valid) and
	t ##7 (state_s == READDATA and !valid) and
	t ##8 (state_s == READDATA and !valid) and
	t ##9 data == tmp and
	t ##9 valid and
	t ##9 state_s == IDLE and
	t ##9 !cnt_en and
	t ##9 cnt_s == 0;
endproperty;

property in_idle_counter_not_enabled__step;
	t ##0 (in_idle_counter_not_enabled and rxd)

	implies

	t ##1 in_idle_counter_not_enabled;
endproperty;

property in_idle_counter_not_enabled__base;
	t ##0 reset_sequence

	implies

	t ##1 in_idle_counter_not_enabled;
endproperty;

property in_idle_counter_is_0__step;
	t ##0 (in_idle_counter_is_0 and rxd) and
	t ##1 (in_idle_counter_is_0 and rxd)

	implies
	
	t ##2 in_idle_counter_is_0;
endproperty;

property in_idle_counter_is_0__base;
	t ##0 reset_sequence and
	t ##1 rxd

	implies
	
	t ##1 in_idle_counter_is_0 and
	t ##2 in_idle_counter_is_0;
endproperty;

// Assert properties
a_reset: assert property (@(posedge clk) reset);
a_stay_in_idle: assert property (@(posedge clk) stay_in_idle);
a_read_byte: assert property (@(posedge clk) disable iff (!reset_n) read_byte);
a_in_idle_counter_not_enabled__step: assert property (@(posedge clk) disable iff (!reset_n) in_idle_counter_not_enabled__step);
a_in_idle_counter_not_enabled__base: assert property (@(posedge clk) in_idle_counter_not_enabled__base);
a_in_idle_counter_is_0__step: assert property (@(posedge clk) disable iff (!reset_n) in_idle_counter_is_0__step);
a_in_idle_counter_is_0__base: assert property (@(posedge clk) in_idle_counter_is_0__base);

`end_tda

endmodule

// Your bind statement
bind readserial readserial_properties inst_readserial_properties(.*);
